from __future__ import print_function, division
from keras.layers import Input, Dense, Reshape, Dropout
from keras.layers import BatchNormalization
from keras.layers.advanced_activations import LeakyReLU
from keras.models import Sequential, Model
from keras.optimizers import Adam
import keras.backend as K
import csv
import numpy as np

class BGAN():
    def __init__(self):
        self.out_shape = (32,)
        self.latent_dim = 50

        optimizerd = Adam(2e-4, 0.5)
        optimizerg = Adam(2e-4, 0.5)

        # Build and compile the discriminator
        self.discriminator = self.build_discriminator()
        self.discriminator.compile(loss='binary_crossentropy',
            optimizer=optimizerd,
            metrics=['accuracy'])

        # Build the generator
        self.generator = self.build_generator()

        # The generator takes noise as input and generated signatures of malware
        z = Input(shape=(self.latent_dim,))
        malware = self.generator(z)

        # For the combined model we will only train the generator
        self.discriminator.trainable = False

        valid = self.discriminator(malware)

        # The combined model  (stacked generator and discriminator)
        # Trains the generator to fool the discriminator
        self.combined = Model(z, valid)
        self.combined.compile(loss=self.boundary_loss, optimizer=optimizerg)

    def build_generator(self):

        model = Sequential()
        model.add(Dense(256, input_dim=self.latent_dim))
        model.add(LeakyReLU(alpha=0.2))
        model.add(BatchNormalization(momentum=0.8))
        model.add(Dropout(0.4))
        model.add(Dense(512))
        model.add(LeakyReLU(alpha=0.2))
        model.add(BatchNormalization(momentum=0.8))
        model.add(Dropout(0.4))
        model.add(Dense(1024))
        model.add(LeakyReLU(alpha=0.2))
        model.add(BatchNormalization(momentum=0.8))
        model.add(Dropout(0.5))
        model.add(Dense(np.prod(self.out_shape), activation='tanh'))
        model.add(Reshape(self.out_shape))
        model.summary()

        noise = Input(shape=(self.latent_dim,))
        malware = model(noise)

        return Model(noise, malware)

    def build_discriminator(self):

        model = Sequential()
        model.add(Dense(512,input_shape=self.out_shape))
        model.add(LeakyReLU(alpha=0.2))
        model.add(Dropout(0.4))
        model.add(Dense(256))
        model.add(LeakyReLU(alpha=0.2))
        model.add(Dropout(0.35))
        model.add(Dense(128))
        model.add(LeakyReLU(alpha=0.2))
        model.add(Dropout(0.35))
        model.add(Dense(64))
        model.add(LeakyReLU(alpha=0.2))
        model.add(Dense(1, activation='sigmoid'))
        model.summary()

        malware = Input(shape=self.out_shape)
        validity = model(malware)

        return Model(malware, validity)

    def boundary_loss(self, y_true, y_pred):
        return 0.5 * K.mean((K.log(y_pred) - K.log(1 - y_pred))**2)

    def train(self, epochs, batch_size=128, sample_interval=50):

        X_train = np.loadtxt('../../heaven/thesis/final_test/colab5/mal_tr4.csv', delimiter=",", skiprows=1)

        valid = np.ones((batch_size, 1))
        valid[:] = 0.7
        fake = np.zeros((batch_size, 1))
        fake[:] = 0.3

        generated_data=[]
        for epoch in range(epochs):

            # ---------------------
            #  Train Discriminator
            # ---------------------
            if epoch==1:
                i=0
                while i<30:
                    # Select a random batch of malware
                    idx = np.random.randint(0, X_train.shape[0], batch_size)
                    malwares = X_train[idx]
                    noise_mal = np.random.normal(0, 0.3, malwares.shape)
                    malwares = malwares+noise_mal
                    noise = np.random.normal(0, 1, (batch_size, self.latent_dim))

                    # Generate a batch of new malware
                    gen_malwares = self.generator.predict(noise)

                    # Train the discriminator
                    d_loss_real = self.discriminator.train_on_batch(malwares, valid)
                    d_loss_fake = self.discriminator.train_on_batch(gen_malwares, fake)
                    d_loss = 0.5 * np.add(d_loss_real, d_loss_fake)
                    print("pre train discriminator")
                    print(d_loss_real)
                    print(d_loss_fake)
                    print(d_loss[0],d_loss[1])
                    i += 1

            j = 0
            while j<15:
                # Select a random batch of malware
                idx = np.random.randint(0, X_train.shape[0], batch_size)
                malwares = X_train[idx]
                noise_mal = np.random.normal(0, 0.35, malwares.shape)
                malwares = malwares + noise_mal
                noise = np.random.normal(0, 1, (batch_size, self.latent_dim))

                # Generate a batch of new malware
                gen_malwares = self.generator.predict(noise)

                # Train the discriminator
                d_loss_real = self.discriminator.train_on_batch(malwares, valid)
                # print(d_loss_real)
                d_loss_fake = self.discriminator.train_on_batch(gen_malwares, fake)
                # print(d_loss_real)
                d_loss = 0.5 * np.add(d_loss_real, d_loss_fake)
                j+=1

            # ---------------------
            #  Train Generator
            # ---------------------
            noise = np.random.normal(0, 1, (batch_size, self.latent_dim))
            g_loss = self.combined.train_on_batch(noise, valid)

            # Plot the progress
            print ("%d [D loss: %f, acc.: %.2f%%] [G loss: %f]" % (epoch, d_loss[0], 100*d_loss[1], g_loss))

            # save generated malware samples
            if  epoch>200:
                generated_data.append(self.sample_malwares(epoch))

        generated_data=np.array(generated_data)
        print(generated_data.shape)
        new = np.reshape(generated_data, (975, 32))
        print(new.shape)

        with open('../../heaven/thesis/final_test/colab5/BGAN_mal.csv', 'w') as csvFile:
            writer = csv.writer(csvFile)
            writer.writerows(new)
        csvFile.close()

    def sample_malwares(self, epoch):
        r, c = 5, 5
        noise = np.random.normal(0, 1, (r * c, self.latent_dim))
        gen_malwares = self.generator.predict(noise)
        return gen_malwares


if __name__ == '__main__':
    bgan = BGAN()
    bgan.train(epochs=240, batch_size=80, sample_interval=100)
